@startuml

title GUI Classes

namespace rsp::graphics {

class Point {
    A simple class with properties\nfor a 2D coordinate.
    --
    +mX: integer
    +mY: integer
    --
    +Point()
    +Point(aX: int, aY: int)
    +Point(arPoint: constant Point&)
    +operator=(arPoint: constant Point&): Point&
    +operator+=(arPoint: constant Point&): Point&
    +operator-=(arPoint: constant Point&): Point&
    +operator==(arPoint: constant Point&): boolean
    +operator!=(arPoint: constant Point&): boolean
    +GetX(): integer
    +SetX(aValue: integer)
    +GetY(): integer
    +SetY(aValue: integer)
}

class Rect {
    A class with two Point properties.
    --
    #mLeftTop: Point
    #mRightBottom: Point
    --
    +Rect()
    +Rect(aTop: integer, aLeft: integer, aWidth: integer, aHeight: integer)
    +Rect(arTopLeft: const Point&, aWidth: integer, aHeight: integer)
    +Rect(arTopLeft: constant Point&, arBottomRight: constant Point&)
    +Rect(arRect: constant Rect&)
    +operator=(const Rect &arRect): Rect&
    +operator==(const Rect &arRect): bool
    +operator!=(const Rect &arRect): bool

    +GetTop(): integer
    +SetTop(aValue: integer)
    +GetBottom(): integer
    +SetBottom(aBotValue: integer)
    +GetLeft(): integer
    +SetLeft(aLeftValue: integer)
    +GetRight(): integer
    +SetRight(aRightValue: integer)

    +GetTopLeft(): Point&
    +GetBottomRight(): Point&
    +GetWidth(): integer
    +SetWidth(aValue: integer)
    +GetHeight(): integer
    +SetHeight(aValue: integer)
    +IsHit(arPoint: constant Point&): boolean 
}
Point *-- Rect

class Color {
    Class with uint32_t property for ARGB
    color information.
    The alpha channel is used for opacity.
    Not all platforms support alpha blending.
    --
    #mValue: ARGB_t
    --
    +Color(aRed: uint8_t, aGreen: uint8_t, aBlue: uint8_t, aAlpha: uint8_t)
    +Color(aARGB: ARGB_t)
    +Color(arColor: const Color&)
    +GetRed(): uint8_t
    +SetRed(aValue: uint8_t)
    +GetGreen(): uint8_t
    +SetGreen(aValue: uint8_t)
    +GetBlue(): uint8_t
    +SetBlue(aValue: uint8_t)
    +GetAlpha(): uint8_t
    +SetAlpha(aValue: uint8_t)
    +operator ARGB_t(): uint32_t
    +operator=(arColor: const Color&): Color&
}

class Bitmap {
    Class to handle raster images.
    Can load bmp and png files through
    filesystem and do some basic
    manipulation like resize/stretch.
    --
    +Bitmap(arImgName: const std::string&)
    +Bitmap(apPixels: const uint32_t*, aHeight: integer, aWidth: integer, aBytesPerPixel:integer)
    +Bitmap(aHeight: integer, aWidth: integer, aBytesPerPixel: integer)
    +SetPixel(arPoint: const Point&, aColor: Color)
    +GetPixel(arPoint: const Point&, aFront: boolean = false): uint32_t
    +GetHeight(): integer
    +GetWidth(): integer
    +GetPixels(): const std::vector<uint32_t>&
}

abstract Canvas {
    All drawing operations are performed on a Canvas.
    Descendants can implement in memory canvas, Linux
    Framebuffer canvas or even a DirectX Canvas.
    --
    +DrawArc(arCenter: const Point&, aRadius1: integer, aRadius2: integer, aStartAngle: integer, aSweepAngle: integer, arColor: constant Color&)
    +DrawCircle(arCenter: constant Point&, aRadius: integer, arColor: constant Color&)
    +DrawLine(arA: constant Point&, arB: constant Point&, aColor: Color)
    +DrawRectangle(arRect: constant Rect&, arColor: constant Color&, aFilled: boolean = false)
    +DrawImage(arTopLeft: constant Point&, arBitmap: constant Bitmap&)
    +DrawText(arText: constant Text&, arColor: constant Color&)
    +DrawText(arText: Text&)
    +{abstract}GetPixel(arPoint: const Point&, aFront: constant boolean = false): uint32_t
    +{abstract}SetPixel(arPoint: const Point&, aColor: constant Color)
    +GetWidth(): integer
    +GetHeight(): integer
    +GetColorDepth(): integer
    +IsInsideScreen(arPoint: constant Point&): boolean
}
Canvas <|-- Bitmap

enum BufferedCanvas::SwapOperations
{
    When swapping buffers these values can control
    the baseline content of the new buffer.
    --
    NoOp // No initialization of the buffer is performed
    Copy  // The current view content is copied int new buffer
    Clear // The new buffer is filled with the background color
}

interface BufferedCanvas {
    +{abstract}SwapBuffers(aOperation: SwapOperations);
}

BufferedCanvas::SwapOperations ... BufferedCanvas
Canvas <|-- BufferedCanvas

class FrameBuffer {
    +Framebuffer(apDevicePath: const char* = nullptr)
}
BufferedCanvas <|-- FrameBuffer

class TouchArea {
    #mTouchArea: Rect
    --
    +ProcessInput(arInput: Input&): bool
    +IsHit(arPoint: const Point&) const: bool
}
Rect *-- TouchArea

class Control {
    The base GUI element. All other elements
    decent from the Control class.
    Control objects contains a boolean "invalidated"
    property, this is flagged in case the object needs
    rendering. Setter functions can invalidate a Control
    object.
    --
    #mBackground: Color
    #mTransparent: bool
    #mArea: Rect
    #mpParent: Control*
    #mChildren: std::vector<Control*>
    --
    +Invalidate()
    +IsInvalid() const: bool
    +IsTransparent() const: bool
    +Render(arCanvas: Canvas&)
    +SetArea(arRect: const Rect&)
    +GetArea(): Rect&
}
Color *-up- Control
Rect *-- Control

class Scene {
    Each fullscreen view must decent from Scene.
    --
    #mTouchables: std::vector<TouchArea*>
    --
    +ProcessInput(arInput: Input&)
}
Control <|-- Scene 

class Image {
    A control to draw bitmap images.
    --
    #mBitmap: Bitmap
}
Control <|-- Image
Bitmap *-- Image

class Label {
    A control used to draw text and graphics.
    --
    #mCaption: string
    #mFont: Font
    --
    +SetCaption(arCaption: const string&)
}
Control <|-- Label
Text *-- Label

class GraphicsMain{
    Runs the gui loop, controls the current active scene and changes scenes when needed
    --
    -BufferedCanvas &mBufferedCanvas;
    -InputCreator &mInputs;
    -SceneLoader &mSceneLoader;
    -Scene mActiveScene;
    -bool mTerminated = false;
    -std::vector<Input> inputCache{};
    --
    +GraphicsMain(BufferedCanvas &aCanvas, InputCreator &aInputs, SceneLoader &aSceneLoader);
    +~GraphicsMain();

    +void Run();
    +void Terminate() { mTerminated = true; }
    +void ChangeScene(std::string aSceneName);
    +void handleEvent(Event &newEvent) override;
}

class SceneLoader{
    Holds all scenes in an unordered maps and gets them by reference
    --
    +std::unordered_map<std::string, Scene> mSceneMap;
    --
    +SceneLoader(Broker &aBroker);
    +Scene &GetFirstScene();
    +Scene &GetScene(std::string aSceneName);
}
SceneLoader --* Scene
GraphicsMain --* SceneLoader
GraphicsMain --* Canvas


}

@enduml

